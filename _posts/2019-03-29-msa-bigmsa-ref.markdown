---
layout: post
title: 대규모 마이크로서비스
date: 2019-03-29
categories: msa
author: himang10
tags: [msa, architecture]
---

# Table of Contents
1. [장애는 어디에서나 발생한다](#장애는_어디에서나_발생한다)
2. [얼마나 많아야 너무 많은 건가](#얼마나_많아야_너무_많은_건가)
3. [기능 분해](#기능_분해)
3. [아키텍처 안전 조치](#아키텍처_안전_조치)
3. [안티프래질 조직](#안티프래질_조직)
3. [데이터베이스 확장](#데이터베이스_확장)

## 대규모 마이크로서비스

### 장애는 어디에서나 발생한다
장애는 대규모 환경에서 통계적으로 필연적이다.

아주 극단적인 규모를 고려하지 않더라도 실패의 가능성을 수용하는 편이 낫다. 
> 한서비스의 장애를 훌륭히 처리할 수 있다면 예상치 못한 중당 (Outage)보다 *** 계획된 중단 ***이 훨씬 처리하기 쉽기 때문에 서비스의 현장 업그레이드 (in-place upgrade)도 수용할 수 있다.

```
불가피한 것을 막는데 좀 더 적은 시간을, 그리고 그것을 세련되게 처리하는 데 더 많은 시간을 할애할 수 도 있다.
처음 발생한 장애를 실제로 더 쉽게 복구할 생각을 해야 한다
```

### 얼마나 많아야 너무 많은 건가
교차 기능 요구 사항의 이해는 데이터의 내구성, 서비스 가용성, 처리량, 서비스의 허용 지연시간 같은 측면을 모두 고려

1) 증가하는 부하나 개별 노드의 고장에도 반응할 수 있는 자동 확장 시스템이 있다면 멋진 일, 그러나 한달에 겨우 두번 실행하고 하루 이틀 동안 다운되는 것이 그다지 대수롭지 않다.

2) 온라인 전자 상거래를 위해 서비스의 다운타임을 없애기 위한 B/G 배포의 방법을 찾는 것은 합당하지만 자사 인프라넷 지식 기반 시스템을 위해 사용하는 것은 너무 앞서가는 것

교차기능 요구사항은 서비스 마다 다르다

#### 응답시간/지연시간
소프트웨어가 처리할 동시 접속 및 사용자수 또한 포함
```
웹사이트가 초당 200개의 동시 접속수를 처리할 때 응답시간의 90%가 2초 미만을 유지할 것으로 예상된다
```

#### 가용성
서비스가 응답하든 안 하든 사용할 수 있어야 한다.

#### 데이터 내구성
얼마나 많은 데이터 손실이 허용 가능한가? 얼마나 오랜 기간 데이터를 보관해야 하는가? 이 질문은 경우에 따라 매우 다를 것이다.
```
사용자 세션 로그의 보관 기간은 1년 또는 공간 절약을 위해 그 이하로 선택할 수 있지만 금융 거래 기록은 수년 동안 보관해야 할 수도 있다
```

### 기능 분해
회복력이 있는 시스템 구축에서 가장 중요한 것 중 하나는 안전하게 기능을 분해할 수 있는 능력이다.

### 아키텍처 안전 조치
무언가 잘못될 때 벌어지는 심각한 파급효과를 막기 위한 몇가 지 패턴을 아키텍처 안전 조치 (architecture safety measure)라 정의한다.

```
매우 느린 응답은 가장 나쁜 장애의 유형이다. 차라리 시스템이 전혀 동작하지 않는다면 문제를 더 빨리 찾아내겠지만 단순히 느려진다면 결국 동작을 포기하기 전까지 한참을 기다려야한다. 
```

예를들어, 외부의 모든 요청에 대해 하나의 HTTP 커넥션을 공유하고 있는 것은 모든 서비스가 정상인 상태에서도 느린 서비스 하나로 모든 가용한 작업자 스레드가 소진될 수 있다는 것을 의미한다. 
문제의 하위 서비스가 정상 상태가 아님이 분명할때도 우리는 트래픽을 계속 그쪽으로 전송하도록 한다. 그 상황에서 하위 서비스가 복구될 가능성은 희박하게 되면 실제로 상황은 더욱 악화될 수 있다.
결국 재발을 막기 위해서는 사 가지 조치를 취할 필요가 있다
* 커넥션 풀을 분리하기 위한 격벽 (bulkhead)
* 정상 동작하지 않는 시스템은 애초에 호출하지 않도록 회로차단(circuit breaker)를 적용

### 안티프래질 조직
chaos monkey는 넷플릭스의 장애를 만드는 봇인 simian army의 일부
chaos gorilla는 전체 가용성 센터르 검토
latency monkey는 머신 간의 느린 네트워크 접속 상황 시뮬레이션

#### 타임아웃
모든 프로세스의 경계 외부의 호출에 타임아웃을 넣고 항상 기본 타임아웃 시간을 설정하라. 타임아웃 발생 시간을 로깅하고 어떤 일이 발생했는지 살펴보며 타임아웃을 적절히 변경하라

#### 회로차단기

<img src="/files/circuitbreaker.jpeg" width="600">

HTTP 커넥션 차단기 구현 시 Timeout이나 5XX HTTP Return code에 해당되는 호출 실패를 두었다.
하위 자원이 다운되거나 타임아웃되거나 에러를 리턴할 때 특정 임계값에 도달한 후 자동적으로 전송 트래픽을 중시지키고 신속히 실패하도록 구성한다. 그리고 정상으로 복구되었을 때 자동으로 재시작한다.

회로차단 시 취할 수 있는 방법 
* 비동기 처리 시 요청을 큐에 넣어두고 나중에 처리. 그러나 동기 호출 방식일 경우에는 빠른 실패가 더 나음

* 정기 유지보수 시 특정 마이크로 서비스를 수동으로 끊어 오프라인동안 요청이 빠르게 실패하게 할 수 있음

#### 격벽
선박의 격벽(bulkhead)은 배의 나머지 부분을 보호하기 위해 밀봉 역할을 하는 선체의 벽을 의미한다.
소프트웨어 아키텍처 측면에서 고려할 수 있는 다양한 격벽이 있다. 
예를들어 커넥션 풀에서 하나의 커넥션 풀을 이용하는 것이 아니라 하위 커넥션 마다 다른 커넥션 풀을 사용하도록 한다. 

<img src="/files/bulkhead.jpeg" width="600">

1. 얽혀 있는 기능을 분리된 마이크로서비스로 분해하여 한 지역의 장애가 다른 지역에 영향을 줄 가능성을 줄인다. 

2. 회로 차단기를 격벽을 밀봉하는 자동 메커니즘으로 간주하여 장애 전파의 위험성을 고려할 때 하위 시스템의 동기식 호출에 회로 차단기를 의무적으로 사용

격벽은 타임아웃, 회로 차단기보다 중요하다. 

#### 격리 
서비스간 격리도를 높이면 서비스들이 서로 분리되면 소유자간 조율할 것도 줄어든다. 팀간 조율이 적어질 수 록 더 자유롭게 서비스를 운영하고 발전시킬 수 있기 때문에 팀의 자율성은 더 높아진다.

### 멱등성 
연산이 연속적으로 여러번 적용되더라도 첫 적용 후의 결과가 달라지지 않는 성질의 연산을 멱등성 (idempotent) 연산이라고 한다.

### 확장성
확장의 목적은 1) 장애에 잘 대응하기 위해, 2) 성능을 위해

#### 더 크게 만들기

#### 작업 부하 나누기
서로 다른 중요도, 처리량을 가지는 서비스는 분리하여 별도로 제공

#### 위험 분산
회복성을 위해 확장하는 한가지 방법은 계란을 한 바구니에 담지 않는 것이다. 예로들어 한 호스트에 여러 서비스를 배포하지 않도록 한다.
#### 부하 분산
다수의 인스턴스가 부하를 공유

#### 작업자 기반 시스템
소프트웨어 작업자를 분산하는 방버. 예를들어, 큐에 들어오는 이벤트를 여러개의 워커가 작업하는 것을 의미한다.

### 데이터베이스 확장

#### 서비스의 가용성과 데이터의 내구성
서비스의 가용성과 데이터의 내구성 개념을 분리하는 것은 중요하다.
가용성은 서비스가 연속해서 제공되는 것을 의미하고 내구성은 서비스가 연속해서 진행되지 않더라도 복구가 가능한 구조를 의미한다.

#### 읽기용 확장
최종적 일관성을 유지 (Eventually consistency)

#### CQRS
명령과 질의에 대한 책임 분리 (Command-Query Reponsiblity Segregation)
명령과 질의를 처리하는 데 사용된 내부 모델들은 그 자체로 완전히 분리된다는 것이다. 에를들어 명령을 이벤트로 처리하고 프로세싱하도록 선택하고 명령 리스트를 데이터 저장소에 저장할 수 있다. 
이과정을 Event Sourcing이라고 한다.

### CAP 정리
* Consistency: 다수의 노드로부터 동일한 대답을 얻어야 한다는 시스템 특성
* availability: 모든 요청은 응답을 받는 다는 것의 의미
* partition tolerance: 시스템 부분 간의 통신이 가끔씩 실패한다는 사실을 다루는 시스템의 능력

### 마이크로 서비스의 원칙

<img src="/files/msarule.jpeg" width="600">

#### 비즈니스 개념에 따른 모델
기술적 개념에 맞춰 구성된 인터페이스보다 비즈니스 경계로 나눠진 context가 안정정이다. 
잠재적인 도메인 경계를 정의하기 위해서는 경계가 있는 콘텍스트 (bounded context)를 이용하라

#### 자동화 문화의 적용
CI/CD, 자동화 테스팅

#### 내부 세부 구현의 은폐
한서비스가 다른 서비스와 독립적으로 진화하는 능력을 극대화시키기 위해 세부 구현을 은폐하는 것은 필수적이다. 
경계가 있는 콘텍스트로 모델링하는 것은 
  공유되고 은폐되어야 하는 모델에 집중하므로 도움이 된다. 
  * 가장 흔한 종류의 결합 문제에 빠지지 않도록 그들의 데이터베이스를 감추어라
  * 데이터를 통합하기 위해 ` 데이터 펌프 `, ` 이벤트 데이터 펌프 `를 사용하라
  * 다른 기술 스택을 자유롭게 사용하도록 ` 기술중립적 API` 를 선택하라
  
#### 모든 것을 분권화
마이크로서비스가 도달 할 수 있는 자율성을 극대화하기 위해 우리는 각 서비스를 소유한 팀에 의사결정과 통제를 위임할 기회를 꾸준히 찾아야 한다.
* 셀프서비스의 자세를 수용
* 팀이 그들의 서비스를 소유하로록 보장
* 콘웨이 법칙이 효과가 있도록 팀 조직을 변경
* 각 팀이 서비스의 비즈니스 분야 전문가가 될수 있도록 해라
* 비즈니스 로직과 멍청한 서비스 (단순 서비스)를 한데 집중시키는 ESB와 Orchestration system을 멀리하라
* orchestration과 무거운 Middleware 대신 choreagraphy를 선호하라.

커리어그라피는 ` 서비스 경계내애서 로직과 데이터 연관성을 보장 `하는 ### 영리한 엔드포인트 ###로 응집력을 유지하게 한다.

#### 독립적인 배포
마이크로서비스에는 호환성을 깨드리는 변경이 필요할 때 소비자 서비스가 시간을 두고 변경할 수 있도록 *** 여러 버전의 엔드포인트가 공존 ***되도록 해야 한다.
결국 하나의 마이크로 서비스에 여러 버전의 서비스가 버전 정보를 가지고 있는 URL 여러개를 제공할 수 있어야 한다.

> 서비스의 소비자가 자신을 업데이트 할때를 결정해야 한다. 

#### 장애 격리
장애도 시스템의 일 부분으로 이해하고 계획할 경우에만 더 회복성이 좋다.
하위 호출의 실패 가능성을 고려하지 않는다면 시스템은 재앙적 전파 장애를 겪고 전보다 훨씬 더 취약한 시스템이 될 것이다. 

#### 매우 식별 가능한
상황에 대한 통합된 뷰가 필요하다. 
까다로운 이슈를 재현하거나 실환경에서 시스템이 어떻게 상호작용하는지 확인하고 싶을 경우 시스템 간 모든 호출을 추적할 수 있도록 상관관계 ID를 사용하라

### 언제 마이크로서비스를 사용하지 않아야 하는가?
우선 모노리틱으로 시작하고 안정화되면 분해하라
