---
layout: post
title: 마이크로서비스 아키텍처
date: 2019-05-20
categories: MSA
author: himang10
tags: [msa, principle]
---

### Agile한 비즈니스 혁신을 위한 마이크로서비스 도입
마이크로 서비스의 필요성을 논하기 위해서는 우선 고객과 시장의 변화를 봐야 합니다. 
고객과 시장의 변화는 예전에는 오랜 시간을 두고 천천히 발생하고 오랜동안 지속되었다면 현재는 우리가 인지하는 속도보다 빠르게 변화하고 대응하고 있습니다.
고객의 요구 사항의 변환, 기술의 변화, 그리고 이를 신속하게 수용해서 적용하여야지만 살아 남을 수 있는 세상이 된 것입니다. 
이를 위해 기업은 새로운 비즈니스를 발굴하고 발빠르게 개발 적용, 검증을 통해 지속적 개선, 성장을 이루어 나가야 합니다.
어떤 때에는 과감하게 기존 것을 버리고 새롭게 바꾸어 나가야 합니다. 
그러나 이러한 비즈니스 환경 변화에 기존 모노티릭한 아키텍처와 인프라 구조에서는 맞출 수가 없습니다. 
결국 이를 지원하기 위해서는 애플리케이션의 라이프 사이클과 인프라의 라이프 사이클이 맞춰나가 하는데 이것이 바로 MSA, CI/CD 이며,
이를 지원하기 위한 플랫폼이 Container PaaS, SDDC 입니다. 

> 결국 마이크로 서비스와 클라우드는 사업 전개 속도를 가속화시켜주며, 이것은 비즈니스의 경쟁력을 강화하는 것이다.

> "사업 전개 속도를 높이는 것", "시장의 변화에 민첩하게 대응하는 것", "생존을 위해 빠르게 실패하는 것", "새로운 기술을 빠르게 받아들이는 것"
> "시장에 빠르게 적응하고, 실패하고, 개선하고, 답을 찾아 나가는 것"

### 마이크로서비스 아키텍처는 언제 필요한가?

모든 애플리케이션이 마이크로서비스 아키텍처 패턴으로 구성될 필요는 없습니다. 특히, 적은 인원으로 빠르게 시작해야하는 스타트업의 경우 앞으로 어떤 서비스와 컴포넌트가 필요하게 될 지 예측할 수 없는 상황에서 과도하게 시스템을 여러개의 서비스로 쪼갤 필요는 없습니다. (물론, 서비스에 대한 로드맵이 명확하여 초기에 시스템을 마이크로서비스 형태로 구성하는 것도 가능합니다). 그렇다면, 구체적으로 어느 시점에 마이크로서비스 아키텍처에 대해서 고려하는 것이 좋을까요? 일반적으로 다음의 항목들 중에서 대부분이 현재 상황에 해당한다고 생각되면 마이크로서비스 아키텍처 패턴에 대해서 고민을 시작해 보는 것도 나쁘지 않습니다.

1. 애플리케이션의 배포에 한 시간 이상 소요된다.
2. 단순한 기능 하나를 수정해도 전체 기능에 대한 QA가 필요하다.
3. 단순한 버그 수정이 더 중대한 버그를 생산하는 일이 많아졌다.
4. 현재의 애플리케이션을 기능별로 나눈다고 가정했을 때 수십개의 마이크로서비스가 가능하다.

### 모놀리틱 아키텍처 (Monolithic Architecture)

<img src="/files/monolithic.png" width="600"> 

#### 장점

애플리케이션은 로컬 환경에서 개발하기에도 편리하고 통합 시나리오 테스트를 수행하기에도 가장 손쉬운 구성입니다. 
또한, 모든 코드가 하나의 묶음으로 구성되어 있기 때문에 배포도 매우 간편해집니다.
* 로컬 개발 편리하며
* 통합 시험 수행 용이
* 전체 배포 용이

#### 단점
이러한 단순한 애플리케이션의 아키텍처는 서비스가 지속적으로 성장하고 규모가 커질 때 한계에 부딪히게 됩니다. 예를 들어, 3명의 개발자가 몇 가지 핵심 기능을 개발할 때에는 이와 같은 모놀리틱 아키텍처가 최적의 효율성을 보장하지만 개발자의 규모가 수십에서 백명 이상이 되고 서비스의 복잡도가 증가되면 아주 간단한 기능을 하나 추가하기 위해서도 매우 많은 줄의 코드를 수정해야함은 물론, 코드의 변화가 영향을 미치는 범위가 증가되었기 때문에 간단한 변화 하나에도 통합 테스트가 필요하게 됩니다.
* 개발 규모가 커지고 서비스의 복잡도가 증가될 경우 기능 개선/추가 시 연관코드 전체의 변경이 필요하며 이로 인한 전체 통합 시험이 불가 피
* 이 문제를 해소하기 위해 애자일 등의 방법론을 도입하지만 이것 역시 구조 자체의 복잡도로 인해 해결이 어려움 
* 복잡한 구조는 향후 전체 코드의 해독/이해가 불가하게 되며 이로 인해 공통 코드 이용하지 않고 중복된 코드 재생산 발생
** 사용하지 않는 코드가 시술 부채로 계속 쌓임
* 코드가 각 개발 시점에서 서로 다른 방식으로 연관되어 있기 때문에 간단한 버그 수정이 더 큰 버그를 앙산할 가능성이 높아짐

서비스 복잡도가 증가하게 되면 결국
* 배포 시간의 증가
* 부분적 스케일 아웃의 어려움
* 안정성의 감소 (안정화를 위한 투자 시간 및 노력 증가)
* 프로그램 언어, 프래임워크에 대한 기능 개선 시 변경 불가
  예) 프레임워크나 언어의 변화가 어떤 코드에 영향을 줄지 추적 불가
  

### 마이크로서비스 아키텍처 (Microservice Architecture)

모놀리틱 아키텍처로 구성된 하나의 큰 서비스를 **독립적인 역할**을 수행하는 작은 단위의 서비스로 분리하여 설계하는 패턴을 말합니다 (책임의 분리)
> 독립적인 역할이란 주로, ‘사용자 관리’, ‘주문 관리’, ‘결제 관리’, ‘알림 관리’와 같이 기능적인 요소를 의미

각각의 마이크로서비스는 그 크기만 작을 뿐, 자세히 살펴보면 각각이 하나의 모놀리틱 아키텍처와 유사한 구조를 갖습니다. 다만, 하나의 서비스에서 처리해야 하는 기능과 규모가 작기 때문에 이를 마이크로서비스라고 부릅니다.

<img src="/files/micro-service-architecture.png" width="600">

마이크로서비스 아키텍처를 나타낸 그림에서 주목할 점은 사용자를 위한 데이터베이스와, 주문을 위한 데이터베이스가 따로 표시되어 있다는 점입니다. 이 부분은 실제로 마이크로서비스 아키텍처를 구현할 때 매우 중요한 부분인데, 전통적인 모놀리틱 아키텍처에서 주로 개발을 했던 경험에 비추어 보면 데이터의 트랜잭션 관리나 정규화 등의 관점에서 매우 비효율적으로 보일 수 있습니다. 물론, 하나의 데이터베이스를 각각의 개별 서비스가 공유해서 사용하는 방식도 가능하지만 마이크로서비스 아키텍처가 가지는 근본적인 장점을 최대한 활용하기 위해서는 이렇게 서비스별로 별도의 데이터베이스를 사용하는 것이 필요합니다. 또한, 데이터베이스(DBMS)의 종류 자체도 반드시 한가지 통일할 필요 없이 데이터의 특성과 서비스가 가지는 특수성에 따라 가장 효율적인 데이터베이스를 선택하여 사용하는 것도 가능합니다. 예를 들어, 어떤 서비스에서 사용하는 데이터는 변경이 적고 주로 읽기(read) 작업만 수행되는 반면, 또 다른 서비스의 데이터는 읽기 작업보다 빠른 속도로 쓰여지는(write) 작업이 대부분이라면 각각의 서비스 특성에 맞게 데이터베이스의 종류를 결정하고 설계할 수 있습니다.

#### 장점

마이크로서비스 아키텍처는 **서비스의 규모가 커지고 복잡도가 증가할 수록** 여러가지 장점을 갖습니다
* 서비스가 개별적으로 독립적인 단위의 애플리케이션이기 때문에 **변경이 용이**
* 변경이 다른 서비스에 미치는 영향이 적음
* 서비스 단위로 독립적인 배포가 가능하다는 점
* 개별 서비스 단위의 배포가 가능하기 때문에 하루에도 필요에 따라 여러 번 배포를 하는 것이 가능
* 부하가 집중되는 특정 서비스만 스케일 아웃 지원 (기존 전체 애플리케이션 스케일 아웃 불 필요)
** 특히 자원 특성(CPU, Memory)에 따라 자원 할당 및 확장 지원
* 특정 서비스의 변경이 다른 서비스에 영향을 미칠 가능성이 적다는 점

다시 말해 인증과 관련된 서비스가 독립적으로 분리되어 있다면 해당 서비스의 개선과 수정 작업이 다른 서비스의 이해 당사자들과 독립적으로 진행될 수 있기 때문에 
* 의사 결정이 빠르고,
* 독립적인 테스트의 구축이 용이

이로인해 품질이 증가 하게 된다. 

이로 인한 장점은 다음과 같습니다.
* 장점 1
> 단일체 소프트웨어에서는 코드 저장소로써 개발자는 오직 하나의 언어(예를들면 자바)로 개발합니다. 하지만 마이크로서비스에서는 각 서비스는 독립적이고 새로운 프로젝트이며 요구사항에 맞는 어떠한 언어든지 사용해서 개발될 수 있습니다.

* 장점 2
>개발자는 오직 특정 서비스만 집중하기 때문에 코드 저장소는 매우 작을 것이고 개발자는 코드를 잘 알고 있을 것입니다.

* 장점 3
> 서비스가 다른 서비스와 통신할 필요가 있을때 API를 통해(구체적으로 REST 서비스에 의해) 서비스들은 통신할 수 있습니다. REST 서비스는 커뮤니키에션을 위한 중개자이기 때문에 매우 작은 변환만 있습니다. SOA와는 다르게 마이크로 서비스 메시지 버스는 아주 많은 변환, 분류, 라우팅을 하는 ESB보다 훨씬 더 얇습니다.

* 장점 4
>중앙화된 데이터베이스가 없습니다. 각 모듈은 각자의 데이터베이스를 가지고 있기 때문에 데이터는 분산 되어있습니다. 개발자는 모듈에 따라 NoSQL 또는 관계형 데이터베이스를 사용할 수 있다는 사실은 전에 언급한 폴리글랏 퍼시스턴스를 데뷔시킵니다.
많은 사람들이 SOA와 마이크로서비스가 같은것이라고 생각합니다. 정의에 따르면 같아 보이지만 SOA는 데이터를 관리하고 분류하는 등 많은 책임을 가진 ESB를 통해 서로 다른 시스템간에 통신을 위해 사용되었습니다.
하지만 마이크로서비스는 입력을 한 서비스에서 다른 서비스로 전송만하는 단순 메시지 버스(dumb message bus)를 사용하지만 메시지를 받는 엔드포인트(endpoint)는 전에 언급한 작업들을 할 수 있을 정도로 똑똑합니다. 마이크로서비스는 우둔한 메시지 버스를 가지고 있지만 똑똑한 엔드포인트가 있습니다.
마이크로 서비스는 REST를 통해 통신을 하며 변환 범위는 API를 통해 호출하는 다른 서비스에 의존하는 오직 하나의 서비스로 아주 작습니다.


> 직의 의사결정 프로세스와 테스트 및 배포 프로세스 등 많은 부분에 영향을 미친다는 것을 의미

#### 단점

* 서비스 간의 통신에 대한 처리가 추가적으로 필요하며, 이로 인해 사용자의 요청을 처리하기 위한 응답속도의 증가에 영향을 미침
> 모놀리틱 소프트웨어의 프로세스간 통신에 비해 좀더 큰 오버헤드를 가지는 API/RPC 호출을 통해 통신 실행 

* 분산된 데이터베이스는 트랜잭션 관리가 용이하지 않기 때문에 데이터의 정합성을 맞추기 위한 노력이 추가적으로 필요

* 서비스들은 각각 서로 분산되어 있기 때문에 관리 포인트가 증가

* 통합해서 모니터링하고 운영하는 것이 모놀리틱 아키텍처에 비해 매우 어려워짐

* 서비스 장애 시 장애 추적이 어려워 짐

* 서비스간 호출로 인해 호출 흐름을 추적하고 디버깅하기 어려워짐

* 각 서비스에서 발생하는 로그를 중앙에서 모니터링하기 어려워짐

결국 이것은 필연적으로 매우 정교한 배포 자동화와 운영 자동화 등을 필요로 하며 많은 PaaS(Platform as a Service) 서비스, 또는 도커(Docker)와 같은 컨테이너 기술을 활용하여 도움을 받을 수 있습니다.
또한 서비스간 통신 (REST API, Event Driven) 관리를 위한 서비스에 대한 서비스 제공을 받아야 합니다.

<img src="/files/microservice-장단점.png" width="600">

[참고자료-마이크로서비스-총정리 글](https://www.popit.kr/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B4%80%EB%A0%A8-%EA%B8%80-%EC%B4%9D%EC%A0%95%EB%A6%AC/)